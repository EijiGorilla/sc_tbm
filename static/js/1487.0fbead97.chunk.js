"use strict";(self.webpackChunksc_tbm=self.webpackChunksc_tbm||[]).push([[1487,5617,3391],{24648:(e,t,i)=>{i.d(t,{Wq:()=>o,d_:()=>r,g2:()=>c,gT:()=>s,kM:()=>a,l3:()=>h});var n=i(31633);function r(e,t){return{type:(0,n.t$)(t),value:e,unit:t}}function s(e,t){return{type:(0,n.t$)(t),value:e,unit:t}}function o(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"arithmetic";return{type:(0,n.t$)(t),value:e,unit:t,rotationType:i}}function a(e,t){const i=h(e,t);return"angle"===e.type?o(i,t,e.rotationType):function(e,t){return{type:(0,n.t$)(t),value:e,unit:t}}(i,t)}function h(e,t){return(0,n.oU)(e.value,e.unit,t)}function c(e,t,i){if(t===i)return e;switch(i){case"arithmetic":case"geographic":return 90-e}}r(0,"meters"),s(0,"square-meters"),o(0,"radians"),o(0,"degrees"),o(0,"degrees","geographic")},35617:(e,t,i)=>{i.r(t),i.d(t,{hydratedAdapter:()=>h});var n=i(76797),r=i(66388),s=i(13904),o=i(65215),a=i(23701);const h={convertToGEGeometry:function(e,t){if(null==t)return null;let i="cache"in t?t.cache._geVersion:void 0;return null==i&&(i=e.convertJSONToGeometry(t),"cache"in t&&(t.cache._geVersion=i)),i},exportPoint:function(e,t,i){const n=e.hasZ(t),r=e.hasM(t),o=new s.A({x:e.getPointX(t),y:e.getPointY(t),spatialReference:i});return n&&(o.z=e.getPointZ(t)),r&&(o.m=e.getPointM(t)),o.cache._geVersion=t,o},exportPolygon:function(e,t,i){const n=new o.A({rings:e.exportPaths(t),hasZ:e.hasZ(t),hasM:e.hasM(t),spatialReference:i});return n.cache._geVersion=t,n},exportPolyline:function(e,t,i){const n=new a.A({paths:e.exportPaths(t),hasZ:e.hasZ(t),hasM:e.hasM(t),spatialReference:i});return n.cache._geVersion=t,n},exportMultipoint:function(e,t,i){const n=new r.A({hasZ:e.hasZ(t),hasM:e.hasM(t),points:e.exportPoints(t),spatialReference:i});return n.cache._geVersion=t,n},exportExtent:function(e,t,i){const r=e.hasZ(t),s=e.hasM(t),o=new n.A({xmin:e.getXMin(t),ymin:e.getYMin(t),xmax:e.getXMax(t),ymax:e.getYMax(t),spatialReference:i});if(r){const i=e.getZExtent(t);o.zmin=i.vmin,o.zmax=i.vmax}if(s){const i=e.getMExtent(t);o.mmin=i.vmin,o.mmax=i.vmax}return o.cache._geVersion=t,o}}},63391:(e,t,i)=>{i.r(t),i.d(t,{buffer:()=>R,changeDefaultSpatialReferenceTolerance:()=>q,clearDefaultSpatialReferenceTolerance:()=>H,clip:()=>a,contains:()=>c,convexHull:()=>V,crosses:()=>l,cut:()=>h,densify:()=>b,difference:()=>E,disjoint:()=>f,distance:()=>d,equals:()=>u,extendedSpatialReferenceInfo:()=>o,flipHorizontal:()=>I,flipVertical:()=>z,generalize:()=>L,geodesicArea:()=>U,geodesicBuffer:()=>D,geodesicDensify:()=>N,geodesicLength:()=>k,intersect:()=>M,intersectLinesToPoints:()=>Y,intersects:()=>p,isSimple:()=>y,nearestCoordinate:()=>P,nearestVertex:()=>G,nearestVertices:()=>Z,offset:()=>w,overlaps:()=>v,planarArea:()=>X,planarLength:()=>O,relate:()=>m,rotate:()=>S,simplify:()=>x,symmetricDifference:()=>A,touches:()=>g,union:()=>T,within:()=>_});var n=i(52612),r=i(35617);function s(e){return Array.isArray(e)?e[0].spatialReference:e&&e.spatialReference}function o(e){return n.G.extendedSpatialReferenceInfo(e)}function a(e,t){return n.G.clip(r.hydratedAdapter,s(e),e,t)}function h(e,t){return n.G.cut(r.hydratedAdapter,s(e),e,t)}function c(e,t){return n.G.contains(r.hydratedAdapter,s(e),e,t)}function l(e,t){return n.G.crosses(r.hydratedAdapter,s(e),e,t)}function d(e,t,i){return n.G.distance(r.hydratedAdapter,s(e),e,t,i)}function u(e,t){return n.G.equals(r.hydratedAdapter,s(e),e,t)}function p(e,t){return n.G.intersects(r.hydratedAdapter,s(e),e,t)}function g(e,t){return n.G.touches(r.hydratedAdapter,s(e),e,t)}function _(e,t){return n.G.within(r.hydratedAdapter,s(e),e,t)}function f(e,t){return n.G.disjoint(r.hydratedAdapter,s(e),e,t)}function v(e,t){return n.G.overlaps(r.hydratedAdapter,s(e),e,t)}function m(e,t,i){return n.G.relate(r.hydratedAdapter,s(e),e,t,i)}function y(e){return n.G.isSimple(r.hydratedAdapter,s(e),e)}function x(e){return n.G.simplify(r.hydratedAdapter,s(e),e)}function V(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return n.G.convexHull(r.hydratedAdapter,s(e),e,t)}function E(e,t){return n.G.difference(r.hydratedAdapter,s(e),e,t)}function A(e,t){return n.G.symmetricDifference(r.hydratedAdapter,s(e),e,t)}function M(e,t){return n.G.intersect(r.hydratedAdapter,s(e),e,t)}function T(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return n.G.union(r.hydratedAdapter,s(e),e,t)}function w(e,t,i,o,a,h){return n.G.offset(r.hydratedAdapter,s(e),e,t,i,o,a,h)}function R(e,t,i){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return n.G.buffer(r.hydratedAdapter,s(e),e,t,i,o)}function D(e,t,i,o,a,h){return n.G.geodesicBuffer(r.hydratedAdapter,s(e),e,t,i,o,a,h)}function P(e,t){let i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return n.G.nearestCoordinate(r.hydratedAdapter,s(e),e,t,i)}function G(e,t){return n.G.nearestVertex(r.hydratedAdapter,s(e),e,t)}function Z(e,t,i,o){return n.G.nearestVertices(r.hydratedAdapter,s(e),e,t,i,o)}function C(e){var t,i;return"xmin"in e?"center"in e?e.center:null:"x"in e?e:"extent"in e&&null!==(t=null===(i=e.extent)||void 0===i?void 0:i.center)&&void 0!==t?t:null}function S(e,t,i){var r;if(null==e)throw new B;const s=e.spatialReference;if(null==(i=null!==(r=i)&&void 0!==r?r:C(e)))throw new B;const o=e.constructor.fromJSON(n.G.rotate(e,t,i));return o.spatialReference=s,o}function I(e,t){var i;if(null==e)throw new B;const r=e.spatialReference;if(null==(t=null!==(i=t)&&void 0!==i?i:C(e)))throw new B;const s=e.constructor.fromJSON(n.G.flipHorizontal(e,t));return s.spatialReference=r,s}function z(e,t){var i;if(null==e)throw new B;const r=e.spatialReference;if(null==(t=null!==(i=t)&&void 0!==i?i:C(e)))throw new B;const s=e.constructor.fromJSON(n.G.flipVertical(e,t));return s.spatialReference=r,s}function L(e,t,i,o){return n.G.generalize(r.hydratedAdapter,s(e),e,t,i,o)}function b(e,t,i){return n.G.densify(r.hydratedAdapter,s(e),e,t,i)}function N(e,t,i){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return n.G.geodesicDensify(r.hydratedAdapter,s(e),e,t,i,o)}function X(e,t){return n.G.planarArea(r.hydratedAdapter,s(e),e,t)}function O(e,t){return n.G.planarLength(r.hydratedAdapter,s(e),e,t)}function U(e,t,i){return n.G.geodesicArea(r.hydratedAdapter,s(e),e,t,i)}function k(e,t,i){return n.G.geodesicLength(r.hydratedAdapter,s(e),e,t,i)}function Y(e,t){return n.G.intersectLinesToPoints(r.hydratedAdapter,s(e),e,t)}function q(e,t){n.G.changeDefaultSpatialReferenceTolerance(e,t)}function H(e){n.G.clearDefaultSpatialReferenceTolerance(e)}class B extends Error{constructor(){super("Illegal Argument Exception")}}},7137:(e,t,i)=>{i.d(t,{Ow:()=>f,TT:()=>p,Xn:()=>x,Zj:()=>v,_3:()=>y,l1:()=>_,qy:()=>g,vN:()=>m});i(35238);var n=i(50076),r=i(31633),s=i(63885),o=i(80963),a=i(23701),h=i(65215),c=(i(13904),i(13312));function l(e){if(!e)return null;if((0,o.EA)(e)&&e.wkid){const t=s.uw[e.wkid];if(t)return t}const t=e.wkt2||e.wkt;if(t){const e=function(e){const t=s._f.exec(e);if(!t||2!==t.length)return null;const i=t[1].split(",");if(!i||i.length<3)return null;const n=parseFloat(i[1]),r=parseFloat(i[2]);return isNaN(n)||isNaN(r)?null:{a:n,f:0===r?0:1/r}}(t);if(e)return e}return null}function d(e){const t=l(e);if(function(e){return null!=e&&"b"in e&&"eSq"in e&&"radius"in e}(t))return t;const i=t.a*(1-t.f);return Object.assign(t,{b:i,eSq:1-(i/t.a)**2,radius:(2*t.a+i)/3,densificationRatio:1e4/((2*t.a+i)/3)})}function u(e,t,i){const{a:n,eSq:r}=d(i),o=Math.sqrt(r),a=Math.sin(t[1]*s.eh),h=n*t[0]*s.eh;let c;return c=r>0?n*((1-r)*(a/(1-r*(a*a))-1/(2*o)*Math.log((1-o*a)/(1+o*a))))*.5:n*a,e[0]=h,e[1]=c,e}function p(e){return null!==l(e)}function g(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"square-meters";if(e.some((e=>!p(e.spatialReference))))throw new n.A("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const i=[];for(let n=0;n<e.length;n++){const t=e[n],r=t.spatialReference,{radius:s,densificationRatio:o}=d(r),a=s*o;i.push(f(t,a))}const s=[],o=[0,0],a=[0,0];for(let n=0;n<i.length;n++){const{rings:e,spatialReference:h}=i[n];let c=0;for(let t=0;t<e.length;t++){const i=e[t];u(o,i[0],h),u(a,i[i.length-1],h);let n=a[0]*o[1]-o[0]*a[1];for(let e=0;e<i.length-1;e++)u(o,i[e+1],h),u(a,i[e],h),n+=a[0]*o[1]-o[0]*a[1];c+=n}c=(0,r.oU)(c,"square-meters",t),s.push(c/-2)}return s}function _(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"meters";if(!e)throw new n.A("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(e.some((e=>!p(e.spatialReference))))throw new n.A("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const i=[];for(let n=0;n<e.length;n++){const s=e[n],{spatialReference:o}=s,a="polyline"===s.type?s.paths:s.rings;let h=0;for(let e=0;e<a.length;e++){const t=a[e];let i=0;for(let e=1;e<t.length;e++){const n=t[e-1][0],r=t[e][0],s=t[e-1][1],a=t[e][1];if(s!==a||n!==r){const e=new v;y(e,[n,s],[r,a],o),i+=e.distance}}h+=i}h=(0,r.oU)(h,"meters",t),i.push(h)}return i}function f(e,t){if("polyline"!==e.type&&"polygon"!==e.type)throw new n.A("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:i}=e;if(!p(i))throw new n.A("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const r="polyline"===e.type?e.paths:e.rings,s=[],o=[0,0],c=new v;for(const n of r){const e=[];s.push(e),e.push([n[0][0],n[0][1]]);let r,a,h=n[0][0],l=n[0][1];for(let s=0;s<n.length-1;s++){if(r=n[s+1][0],a=n[s+1][1],h===r&&l===a)continue;const d=[h,l];y(c,[h,l],[r,a],i);const{azimuth:u,distance:p}=c,g=p/t;if(g>1){for(let n=1;n<=g-1;n++)m(o,d,u,n*t,i),e.push(o.slice(0));m(o,d,u,(p+Math.floor(g-1)*t)/2,i),e.push(o.slice(0))}m(o,d,u,p,i),e.push(o.slice(0)),h=o[0],l=o[1]}}return"polyline"===e.type?new a.A({paths:s,spatialReference:i}):new h.A({rings:s,spatialReference:i})}class v{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;this.distance=e,this.azimuth=t,this.reverseAzimuth=i}}function m(e,t,i,n,r){const o=t[0],a=t[1],h=o*s.eh,c=a*s.eh,l=(null!==i&&void 0!==i?i:0)*s.eh,{a:u,b:p,f:g}=d(r),_=Math.sin(l),f=Math.cos(l),v=(1-g)*Math.tan(c),m=1/Math.sqrt(1+v*v),y=v*m,x=Math.atan2(v,f),V=m*_,E=V*V,A=1-E,M=A*(u*u-p*p)/(p*p),T=1+M/16384*(4096+M*(M*(320-175*M)-768)),w=M/1024*(256+M*(M*(74-47*M)-128));let R,D,P,G,Z=n/(p*T),C=2*Math.PI;for(;Math.abs(Z-C)>1e-12;)P=Math.cos(2*x+Z),R=Math.sin(Z),D=Math.cos(Z),G=w*R*(P+w/4*(D*(2*P*P-1)-w/6*P*(4*R*R-3)*(4*P*P-3))),C=Z,Z=n/(p*T)+G;const S=y*R-m*D*f,I=Math.atan2(y*D+m*R*f,(1-g)*Math.sqrt(E+S*S)),z=Math.atan2(R*_,m*D-y*R*f),L=g/16*A*(4+g*(4-3*A)),b=I/s.eh,N=(h+(z-(1-L)*g*V*(Z+L*R*(P+L*D*(2*P*P-1)))))/s.eh;return e[0]=N,e[1]=b,e}function y(e,t,i,n){const r=t[0]*s.eh,o=t[1]*s.eh,a=i[0]*s.eh,h=i[1]*s.eh,{a:c,b:l,f:u,radius:p}=d(n),g=a-r,_=Math.atan((1-u)*Math.tan(o)),f=Math.atan((1-u)*Math.tan(h)),v=Math.sin(_),m=Math.cos(_),y=Math.sin(f),x=Math.cos(f);let V,E,A,M,T,w,R,D,P,G,Z=1e3,C=g;do{if(R=Math.sin(C),D=Math.cos(C),A=Math.sqrt(x*R*(x*R)+(m*y-v*x*D)*(m*y-v*x*D)),0===A)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;T=v*y+m*x*D,w=Math.atan2(A,T),P=m*x*R/A,E=1-P*P,M=T-2*v*y/E,isNaN(M)&&(M=0),G=u/16*E*(4+u*(4-3*E)),V=C,C=g+(1-G)*u*P*(w+G*A*(M+G*T*(2*M*M-1)))}while(Math.abs(C-V)>1e-12&&--Z>0);if(0===Z){const t=p,i=Math.acos(Math.sin(o)*Math.sin(h)+Math.cos(o)*Math.cos(h)*Math.cos(a-r))*t,n=a-r,c=Math.sin(n)*Math.cos(h),l=Math.cos(o)*Math.sin(h)-Math.sin(o)*Math.cos(h)*Math.cos(n),d=Math.atan2(c,l);return e.azimuth=d/s.eh,e.distance=i,e.reverseAzimuth=void 0,e}const S=E*(c*c-l*l)/(l*l),I=S/1024*(256+S*(S*(74-47*S)-128)),z=l*(1+S/16384*(4096+S*(S*(320-175*S)-768)))*(w-I*A*(M+I/4*(T*(2*M*M-1)-I/6*M*(4*A*A-3)*(4*M*M-3)))),L=Math.atan2(x*Math.sin(C),m*y-v*x*Math.cos(C)),b=Math.atan2(m*Math.sin(C),m*y*Math.cos(C)-v*x);return e.azimuth=L/s.eh,e.distance=z,e.reverseAzimuth=b/s.eh,e}function x(e){return p(e)?e:(0,o.K8)(e)?c.A.WGS84:null}},89238:(e,t,i)=>{i.d(t,{BV:()=>g});var n,r=i(19555),s=i(72745),o=i(20664),a=i(9392),h=i(43047),c=i(55855),l=i(13904);!function(e){e[e.Z=0]="Z",e[e.M=1]="M"}(n||(n={}));class d{constructor(e){this.spatialReference=e}createVector(){return this._tag((0,s.vt)())}pointToVector(e){return this._tag((0,s.fA)(e.x,e.y))}arrayToVector(e){return this._tag((0,s.fA)(e[0],e[1]))}vectorToArray(e){return[e[0],e[1]]}pointToArray(e){return[e.x,e.y]}vectorToPoint(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new l.A;return t.x=e[0],t.y=e[1],t.z=void 0,t.m=void 0,t.spatialReference=this.spatialReference,t}arrayToPoint(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new l.A;return t.x=e[0],t.y=e[1],t.z=void 0,t.m=void 0,t.spatialReference=this.spatialReference,t}vectorToDehydratedPoint(e,t){var i;if(e)return null!==(i=t)&&void 0!==i||(t={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}),t.x=e[0],t.y=e[1],t.z=void 0,t.m=void 0,t.hasZ=!1,t.hasM=!1,t.spatialReference=this.spatialReference,t}lerp(e,t,i,n){return(0,r.Cc)(n,e,t,i)}addDelta(e,t,i){e[0]+=t,e[1]+=i}distance(e,t){return(0,r.Io)(e,t)}getZ(e){return arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0}hasZ(){return!1}getM(e){return arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0}hasM(){return!1}clone(e){return this._tag((0,s.ci)(e))}copy(e,t){return(0,r.C)(t,e)}fromXYZ(e){return this._tag((0,s.fA)(e[0],e[1]))}toXYZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,a.vt)();return(0,o.s)(t,e[0],e[1],0)}pointToXYZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,a.vt)();return(0,o.s)(t,e.x,e.y,0)}equals(e,t){return(0,r.aI)(e,t)}_tag(e){return e}}class u{constructor(e,t){this._valueType=e,this.spatialReference=t}createVector(){return this._tag((0,a.vt)())}pointToVector(e){return this._tag((0,a.fA)(e.x,e.y,this._valueType===n.Z?e.z:e.m))}arrayToVector(e){return this._tag((0,a.fA)(e[0],e[1],e[2]||0))}vectorToArray(e){return[e[0],e[1],e[2]]}pointToArray(e){return this._valueType===n.Z?[e.x,e.y,e.z]:[e.x,e.y,e.m]}vectorToPoint(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new l.A;return t.x=e[0],t.y=e[1],t.z=this._valueType===n.Z?e[2]:void 0,t.m=this._valueType===n.M?e[2]:void 0,t.spatialReference=this.spatialReference,t}arrayToPoint(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new l.A;return t.x=e[0],t.y=e[1],t.z=this._valueType===n.Z?e[2]:void 0,t.m=this._valueType===n.M?e[2]:void 0,t.spatialReference=this.spatialReference,t}vectorToDehydratedPoint(e,t){var i;if(!e)return;null!==(i=t)&&void 0!==i||(t={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"});const r=this._valueType===n.Z,s=this._valueType===n.M;return t.x=e[0],t.y=e[1],t.z=r?e[2]:void 0,t.m=s?e[2]:void 0,t.hasZ=r,t.hasM=s,t.spatialReference=this.spatialReference,t}lerp(e,t,i,n){return(0,o.m)(n,e,t,i)}addDelta(e,t,i,r){e[0]+=t,e[1]+=i,this._valueType===n.Z&&(e[2]+=r)}distance(e,t){return this._valueType===n.Z?(0,o.q)(e,t):(0,r.Io)(e,t)}getZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;return this._valueType===n.Z?e[2]:t}hasZ(){return this._valueType===n.Z}getM(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;return this._valueType===n.M?e[2]:t}hasM(){return this._valueType===n.M}clone(e){return this._tag((0,a.ci)(e))}copy(e,t){return(0,o.c)(t,e)}fromXYZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this._tag((0,a.fA)(e[0],e[1],this._valueType===n.Z?e.length>2?e[2]:t:i))}toXYZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,a.vt)();return(0,o.s)(t,e[0],e[1],this._valueType===n.Z?e[2]:0)}pointToXYZ(e){var t;let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,a.vt)();return(0,o.s)(i,e.x,e.y,this._valueType===n.Z&&null!==(t=e.z)&&void 0!==t?t:0)}equals(e,t){return(0,o.G)(e,t)}_tag(e){return e}}class p{constructor(e){this.spatialReference=e}createVector(){return this._tag((0,c.vt)())}pointToVector(e){return this._tag((0,c.fA)(e.x,e.y,e.z,e.m))}arrayToVector(e){return this._tag((0,c.fA)(e[0],e[1],e[2]||0,e[3]||0))}vectorToArray(e){return[e[0],e[1],e[2],e[3]]}pointToArray(e){return[e.x,e.y,e.z,e.m]}vectorToPoint(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new l.A;return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.spatialReference=this.spatialReference,t}arrayToPoint(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new l.A;return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.spatialReference=this.spatialReference,t}vectorToDehydratedPoint(e,t){var i;if(e)return null!==(i=t)&&void 0!==i||(t={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}),t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.hasZ=!0,t.hasM=!0,t.spatialReference=this.spatialReference,t}lerp(e,t,i,n){return(0,h.l)(n,e,t,i)}addDelta(e,t,i,n){e[0]+=t,e[1]+=i,e[2]+=n}distance(e,t){return(0,o.q)(e,t)}getZ(e){return e[2]}hasZ(){return!0}getM(e){return e[3]}hasM(){return!0}clone(e){return this._tag((0,c.ci)(e))}copy(e,t){return(0,h.c)(t,e)}fromXYZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this._tag((0,c.fA)(e[0],e[1],e.length>2?e[2]:t,i))}toXYZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,a.vt)();return(0,o.s)(t,e[0],e[1],e[2])}pointToXYZ(e){var t;let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,a.vt)();return(0,o.s)(i,e.x,e.y,null!==(t=e.z)&&void 0!==t?t:0)}equals(e,t){return(0,h.e)(e,t)}_tag(e){return e}}function g(e,t,i){return e&&t?new p(i):t?new u(n.M,i):e?new u(n.Z,i):new d(i)}},974:(e,t,i)=>{i.d(t,{uA:()=>u,oH:()=>d,ZE:()=>p,Li:()=>l});var n=i(18690),r=i(54099),s=i(65215),o=i(23701),a=i(89238),h=i(80963),c=i(64465);class l{constructor(e){this.component=e,this.leftEdge=null,this.rightEdge=null,this.type="vertex",this.index=null}get pos(){return this._pos}set pos(e){this._pos=e,this.component.unnormalizeVertexPositions()}}class d{constructor(e,t,i){this.component=e,this.leftVertex=t,this.rightVertex=i,this.type="edge",t.rightEdge=this,i.leftEdge=this}}class u{constructor(e,t){this._spatialReference=e,this._viewingMode=t,this.vertices=[],this.edges=[],this.index=null}unnormalizeVertexPositions(){this.vertices.length<=1||function(e,t){if(!t.supported)return;let i=1/0,n=-1/0;const r=t.upperBoundX-t.lowerBoundX;e.forEach((e=>{let s=e.pos[0];for(;s<t.lowerBoundX;)s+=r;for(;s>t.upperBoundX;)s-=r;i=Math.min(i,s),n=Math.max(n,s),e.pos[0]=s}));const s=n-i;r-s<s&&e.forEach((e=>{e.pos[0]<0&&(e.pos[0]+=r)}))}(this.vertices,function(e,t){const i=(0,h.Vp)(e);return t===c.RT.Global&&i?{supported:!0,lowerBoundX:i.valid[0],upperBoundX:i.valid[1]}:{supported:!1,lowerBoundX:null,upperBoundX:null}}(this._spatialReference,this._viewingMode))}updateVertexIndex(e,t){if(0===this.vertices.length)return;const i=this.vertices[0];let n=null,r=e,s=t;do{n=r,n.index=s++,r=n.rightEdge?n.rightEdge.rightVertex:null}while(null!=r&&r!==i);n.leftEdge&&n!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(n),this.vertices.length-1)}getFirstVertex(){return this.vertices.at(0)}getLastVertex(){return this.vertices.at(-1)}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].leftEdge}swapVertices(e,t){const i=this.vertices[e];this.vertices[e]=this.vertices[t],this.vertices[t]=i}iterateVertices(e){if(0===this.vertices.length)return;const t=this.vertices[0];let i=t;do{e(i,i.index),i=null!=i.rightEdge?i.rightEdge.rightVertex:null}while(i!==t&&null!=i)}}class p extends r.A{constructor(e,t){super(),this.type=e,this.coordinateHelper=t,this._geometry=null,this._dirty=!0,this.components=[]}get geometry(){if(this._dirty){switch(this.type){case"point":this._geometry=this._toPoint();break;case"polyline":this._geometry=this._toPolyline();break;case"polygon":this._geometry=this._toPolygon()}this._dirty=!1}return this._geometry}get spatialReference(){return this.coordinateHelper.spatialReference}notifyChanges(e){this._dirty=!0,this.emit("change",e)}_toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos)}_toPolyline(){const e=[],t=this.coordinateHelper.vectorToArray;for(const i of this.components){if(i.vertices.length<1)continue;const n=[];let r=i.vertices.find((e=>null==e.leftEdge));const s=r;do{n.push(t(r.pos)),r=r.rightEdge?r.rightEdge.rightVertex:null}while(r&&r!==s);e.push(n)}return new o.A({paths:e,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}_toPolygon(){const e=[],t=this.coordinateHelper.vectorToArray;for(const i of this.components){if(i.vertices.length<1)continue;const n=[],r=i.vertices[0];let s=r;const o=s;do{n.push(t(s.pos)),s=null!=s.rightEdge?s.rightEdge.rightVertex:null}while(s&&s!==o);i.isClosed()&&n.push(t(r.pos)),e.push(n)}return new s.A({rings:e,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(e,t){const i=e.spatialReference,r=(0,a.BV)(e.hasZ,e.hasM,i),s=new p(e.type,r);switch(e.type){case"polygon":{const o=e.rings;for(let e=0;e<o.length;++e){const a=o[e],h=new u(i,t);h.index=e;const c=a.length>2&&(0,n.aI)(a[0],a[a.length-1]),p=c?a.length-1:a.length;for(let e=0;e<p;++e){const t=r.arrayToVector(a[e]),i=new l(h);h.vertices.push(i),i.pos=t,i.index=e}const g=h.vertices.length-1;for(let e=0;e<g;++e){const t=h.vertices[e],i=h.vertices[e+1],n=new d(h,t,i);h.edges.push(n)}if(c){const e=new d(h,h.vertices[h.vertices.length-1],h.vertices[0]);h.edges.push(e)}s.components.push(h)}break}case"polyline":{const n=e.paths;for(let e=0;e<n.length;++e){const o=n[e],a=new u(i,t);a.index=e;const h=o.length;for(let e=0;e<h;++e){const t=r.arrayToVector(o[e]),i=new l(a);a.vertices.push(i),i.pos=t,i.index=e}const c=a.vertices.length-1;for(let e=0;e<c;++e){const t=a.vertices[e],i=a.vertices[e+1],n=new d(a,t,i);a.edges.push(n)}s.components.push(a)}break}case"point":{const n=new u(i,t);n.index=0;const o=new l(n);o.index=0,o.pos=r.pointToVector(e),n.vertices.push(o),s.components.push(n);break}}return s}}},39612:(e,t,i)=>{i.d(t,{p:()=>C});var n,r,s=i(54099),o=i(54901),a=i(974);!function(e){e[e.NEW_STEP=0]="NEW_STEP",e[e.ACCUMULATE_STEPS=1]="ACCUMULATE_STEPS"}(n||(n={}));class h{constructor(e,t,i){this._editGeometry=e,this._component=t,this._pos=i,this._addedVertex=null,this._originalEdge=null,this._left=null,this._right=null}apply(){let e="redo";null==this._addedVertex&&(e="apply",this._addedVertex=new a.Li(this._component));const t=this._component.getLastVertex();if(null==t)this._component.vertices.push(this._addedVertex),this._addedVertex.pos=this._pos,this._addedVertex.index=0;else{let e=null;t.rightEdge&&(this._originalEdge=t.rightEdge,e=this._originalEdge.rightVertex,this._component.edges.splice(this._component.edges.indexOf(this._originalEdge),1)),this._component.vertices.push(this._addedVertex),this._addedVertex.pos=this._pos,null==this._left&&(this._left=new a.oH(this._component,t,this._addedVertex)),this._component.edges.push(this._left),t.rightEdge=this._left,null!=this._originalEdge&&null!=e&&(null==this._right&&(this._right=new a.oH(this._component,this._addedVertex,e)),this._component.edges.push(this._right),e.leftEdge=this._right),this._component.updateVertexIndex(this._addedVertex,t.index+1)}this._editGeometry.notifyChanges({operation:e,addedVertices:[this._addedVertex]})}undo(){null!=this._addedVertex&&(this._component.vertices.splice(this._component.vertices.indexOf(this._addedVertex),1),null!=this._left&&(this._component.edges.splice(this._component.edges.indexOf(this._left),1),this._left.leftVertex.rightEdge=null),null!=this._right&&(this._component.edges.splice(this._component.edges.indexOf(this._right),1),this._right.rightVertex.leftEdge=null),null!=this._originalEdge&&(this._component.edges.push(this._originalEdge),this._originalEdge.leftVertex.rightEdge=this._originalEdge,this._originalEdge.rightVertex.leftEdge=this._originalEdge),null!=this._left?this._component.updateVertexIndex(this._left.leftVertex,this._left.leftVertex.index):this._component.updateVertexIndex(this._addedVertex,0),this._editGeometry.notifyChanges({operation:"undo",removedVertices:[this._addedVertex]}))}accumulate(){return!1}}class c{constructor(e,t,i){this._editGeometry=e,this._vertices=t,this.operation=i,this._undone=!1}apply(){this._vertices.forEach((e=>this.operation.apply(e))),this._editGeometry.components.forEach((e=>e.unnormalizeVertexPositions())),this._editGeometry.notifyChanges({operation:this._undone?"redo":"apply",updatedVertices:this._vertices})}undo(){this._vertices.forEach((e=>this.operation.undo(e))),this._editGeometry.notifyChanges({operation:"undo",updatedVertices:this._vertices}),this._undone=!0}canAccumulate(e){if(this._undone||e._vertices.length!==this._vertices.length)return!1;for(let t=0;t<e._vertices.length;++t)if(e._vertices[t]!==this._vertices[t])return!1;return this.operation.canAccumulate(e.operation)}accumulate(e){return!!(e instanceof c&&this.canAccumulate(e))&&(this._vertices.forEach((t=>this.operation.accumulate(t,e.operation))),this.operation.accumulateParams(e.operation),this._editGeometry.components.forEach((e=>e.unnormalizeVertexPositions())),this._editGeometry.notifyChanges({operation:"apply",updatedVertices:this._vertices}),!0)}}!function(e){e[e.CUMULATIVE=0]="CUMULATIVE",e[e.REPLACE=1]="REPLACE"}(r||(r={}));class l{constructor(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._editGeometry=e,this._vertices=t,this._minNumberOfVertices=i,this.removedVertices=null}apply(){let e="redo";if(null==this.removedVertices){const t=this.removedVertices=[];this._vertices.forEach((e=>{const i=this._removeVertex(e);null!=i&&t.push(i)})),e="apply"}else this.removedVertices.forEach((e=>{this._removeVertex(e.removedVertex)}));this._editGeometry.notifyChanges({operation:e,removedVertices:this._vertices})}undo(){var e;null!==(e=this.removedVertices)&&void 0!==e&&e.forEach((e=>{this._undoRemoveVertex(e)})),this._editGeometry.notifyChanges({operation:"undo",addedVertices:this._vertices})}accumulate(){return!1}_removeVertex(e){const t=e.component;if(t.vertices.length<=this._minNumberOfVertices)return null;const i={removedVertex:e,createdEdge:null},n=e.leftEdge,r=e.rightEdge;return t.vertices.splice(t.vertices.indexOf(e),1),n&&(t.edges.splice(t.edges.indexOf(n),1),n.leftVertex.rightEdge=null),r&&(t.edges.splice(t.edges.indexOf(r),1),r.rightVertex.leftEdge=null),0===e.index&&r&&this._vertices.length>0&&t.swapVertices(t.vertices.indexOf(r.rightVertex),0),n&&r&&(i.createdEdge=new a.oH(t,n.leftVertex,r.rightVertex),t.edges.push(i.createdEdge)),r&&t.updateVertexIndex(r.rightVertex,r.rightVertex.index-1),i}_undoRemoveVertex(e){const t=e.removedVertex,i=e.removedVertex.component,n=t.leftEdge,r=t.rightEdge;e.createdEdge&&i.edges.splice(i.edges.indexOf(e.createdEdge),1),i.vertices.push(t),n&&(i.edges.push(n),n.leftVertex.rightEdge=n),r&&(i.edges.push(r),r.rightVertex.leftEdge=r),i.updateVertexIndex(t,t.index)}}class d{constructor(e,t,i){this._editGeometry=e,this._edge=t,this._t=i,this.createdVertex=null,this._left=null,this._right=null}apply(){let e="redo";const t=this._edge,i=t.component,n=t.leftVertex,r=t.rightVertex;i.edges.splice(i.edges.indexOf(t),1),null==this.createdVertex&&(e="apply",this.createdVertex=new a.Li(t.component)),i.vertices.push(this.createdVertex),this.createdVertex.pos=this._editGeometry.coordinateHelper.lerp(t.leftVertex.pos,t.rightVertex.pos,this._t,this._editGeometry.coordinateHelper.createVector()),null==this._left&&(this._left=new a.oH(i,n,this.createdVertex)),this._left.leftVertex.leftEdge?i.edges.push(this._left):i.edges.unshift(this._left),n.rightEdge=this._left,null==this._right&&(this._right=new a.oH(i,this.createdVertex,r)),i.edges.push(this._right),r.leftEdge=this._right,i.updateVertexIndex(this.createdVertex,n.index+1),this._editGeometry.notifyChanges({operation:e,addedVertices:[this.createdVertex]})}undo(){if(null==this.createdVertex||null==this._left||null==this._right)return null;const e=this._edge,t=e.component,i=this.createdVertex.leftEdge,n=this.createdVertex.rightEdge,r=null===i||void 0===i?void 0:i.leftVertex,s=null===n||void 0===n?void 0:n.rightVertex;t.vertices.splice(t.vertices.indexOf(this.createdVertex),1),t.edges.splice(t.edges.indexOf(this._left),1),t.edges.splice(t.edges.indexOf(this._right),1),this._edge.leftVertex.leftEdge?t.edges.push(this._edge):t.edges.unshift(this._edge),r&&(r.rightEdge=e),s&&(s.leftEdge=e),r&&t.updateVertexIndex(r,r.index),this._editGeometry.notifyChanges({operation:"undo",removedVertices:[this.createdVertex]})}accumulate(){return!1}}class u{constructor(e,t,i){this._editGeometry=e,this._vertex=t,this._pos=i}apply(){const e=null==this._originalPosition;e&&(this._originalPosition=this._vertex.pos),this._apply(e?"apply":"redo")}undo(){this._vertex.pos=this._originalPosition,this._editGeometry.notifyChanges({operation:"undo",updatedVertices:[this._vertex]})}accumulate(e){return e instanceof u&&e._vertex===this._vertex&&(this._pos=e._pos,this._apply("apply"),!0)}_apply(e){this._vertex.pos=this._pos,this._editGeometry.components.forEach((e=>e.unnormalizeVertexPositions())),this._editGeometry.notifyChanges({operation:e,updatedVertices:[this._vertex]})}}var p=i(18690);class g{constructor(e,t){this._editGeometry=e,this._component=t,this._createdEdge=null}apply(){let e="redo";if(null==this._createdEdge){e="apply";const t=this._component.getFirstVertex(),i=this._component.getLastVertex();if(this._component.isClosed()||this._component.vertices.length<3||null==t||null==i)return;this._createdEdge=new a.oH(this._component,i,t)}this._createdEdge.leftVertex.rightEdge=this._createdEdge,this._createdEdge.rightVertex.leftEdge=this._createdEdge,this._component.edges.push(this._createdEdge),this._editGeometry.notifyChanges({operation:e})}undo(){null!=this._createdEdge&&((0,p.TF)(this._component.edges,this._createdEdge),this._createdEdge.leftVertex.rightEdge=null,this._createdEdge.rightVertex.leftEdge=null,this._editGeometry.notifyChanges({operation:"undo"}))}accumulate(){return!1}}class _{constructor(e,t,i,n){this._helper=e,this.dx=t,this.dy=i,this.dz=n}_move(e,t,i,n){this._helper.addDelta(e.pos,t,i,n)}apply(e){this._move(e,this.dx,this.dy,this.dz)}undo(e){this._move(e,-this.dx,-this.dy,-this.dz)}canAccumulate(e){return e instanceof _}accumulate(e,t){this._move(e,t.dx,t.dy,t.dz)}accumulateParams(e){this.dx+=e.dx,this.dy+=e.dy,this.dz+=e.dz}}var f=i(15941),v=i(19555),m=i(72745),y=i(20664),x=i(9392),V=i(13927),E=i(96190),A=i(74050);class M{get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}constructor(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:D.IMMEDIATE;this._helper=e,this._planeType=t,this._edge=i,this.distance=n,this._plane=(0,V.vt)(),this._offsetPlane=(0,V.vt)(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,r===D.IMMEDIATE&&this._initialize()}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){var e,t;const i=this._toXYZ(this._edge.leftVertex.pos),n=this._toXYZ(null===(e=this._edge.leftVertex.leftEdge)||void 0===e||null===(e=e.leftVertex)||void 0===e?void 0:e.pos),r=this._toXYZ(this._edge.rightVertex.pos),s=this._toXYZ(null===(t=this._edge.rightVertex.rightEdge)||void 0===t||null===(t=t.rightVertex)||void 0===t?void 0:t.pos);this._edgeDirection=(0,y.E)((0,x.vt)(),i,r),n?(this._left=this._computeNeighbor(i,n,this._edgeDirection),this._right=this._computeNeighbor(r,s,this._edgeDirection,this._left)):(this._right=this._computeNeighbor(r,s,this._edgeDirection),this._left=this._computeNeighbor(i,n,this._edgeDirection,this._right))}_toXYZ(e){return null!=e?this._helper.toXYZ(e):null}_pointToXYZ(e){return this._toXYZ(this._helper.pointToVector(e))}_computeNeighbor(e,t,i,n){const r=(0,x.vt)();if(t){(0,y.E)(r,e,t);const n=!this._passesBisectingAngleThreshold(r,i);return{start:e,end:t,direction:n?this._bisectVectorsPerpendicular(i,r):r,isOriginalDirection:!n}}return this._helper.hasZ()?n&&((0,y.b)(r,i,n.direction),(0,y.b)(r,r,i),(0,y.n)(r,r),Math.sign(r[1])!==Math.sign(i[0])&&(0,y.h)(r,r,-1)):(0,y.s)(r,-i[1],i[0],0),{start:e,end:t,direction:r,isOriginalDirection:!0}}_passesBisectingAngleThreshold(e,t){const i=Math.abs((0,E.g7)(t,e));return i>=T&&i<=Math.PI-T}_bisectVectorsPerpendicular(e,t){const i=(0,y.k)(e,t)<0?e:(0,y.F)((0,x.vt)(),e),n=Math.abs((0,y.k)(i,t));if(!(n<w||n>1-w))return this._bisectDirection(i,t);const r=(0,y.b)((0,x.vt)(),i,[0,0,1]);return(0,y.n)(r,r)}_bisectDirection(e,t){const i=(0,y.g)((0,x.vt)(),e,t);return(0,y.n)(i,i)}_initializePlane(){const e=this._computeNormalDirection(this._left),t=this._computeNormalDirection(this._right);(0,y.k)(e,t)<0&&(0,y.F)(t,t),(0,V.O_)(this._left.start,this._bisectDirection(e,t),this._plane)}_computeNormalDirection(e){const t=(0,y.b)((0,x.vt)(),e.direction,this._edgeDirection);(0,y.n)(t,t);const i=(0,y.b)((0,x.vt)(),this._edgeDirection,t);return this._planeType===R.XY&&(i[2]=0),(0,y.n)(i,i)}_initializeDistanceConstraints(){null==this._left.end||this.requiresSplitEdgeLeft||this._updateDistanceConstraint((0,V.mN)(this._plane,this._left.end)),null==this._right.end||this.requiresSplitEdgeRight||this._updateDistanceConstraint((0,V.mN)(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(e){e<=0&&(this._minDistance=Math.max(this._minDistance,e)),e>=0&&(this._maxDistance=Math.min(this._maxDistance,e))}_updateIntersectDistanceConstraint(e){const t=(0,V.Qj)(e),i=this._edgeDirection,n=(0,y.g)((0,x.vt)(),this._left.start,this._left.direction),r=(0,y.g)((0,x.vt)(),this._right.start,this._right.direction),s=this._pointInBasis2D((0,m.vt)(),t,i,this._left.start),o=this._pointInBasis2D((0,m.vt)(),t,i,n),a=this._pointInBasis2D((0,m.vt)(),t,i,this._right.start),h=this._pointInBasis2D((0,m.vt)(),t,i,r),[c]=(0,A.jI)({start:o,end:s,type:A.Vv.LINE},{start:h,end:a,type:A.Vv.LINE});if(!c)return;const l=(0,v.Re)((0,m.vt)(),s,o);(0,v.S8)(l,l);const d=(0,v.Re)((0,m.vt)(),c,o),u=(0,v.Om)(l,d),p=(0,y.g)((0,x.vt)(),n,(0,y.h)((0,x.vt)(),this._left.direction,-u)),g=(0,V.mN)(e,p);this._updateDistanceConstraint(g)}_pointInBasis2D(e,t,i,n){return e[0]=(0,E.gr)(t,n),e[1]=(0,E.gr)(i,n),e}_offset(e,t){Number.isFinite(this._minDistance)&&(t=Math.max(this._minDistance,t)),Number.isFinite(this._maxDistance)&&(t=Math.min(this._maxDistance,t)),(0,V.C)(this._offsetPlane,this._plane),this._offsetPlane[3]-=t;const i=(e,t,i)=>null!=t&&(0,V.U5)(this._offsetPlane,e,(0,y.g)((0,x.vt)(),e,t),i),n=(0,x.vt)();(e===this._edge.leftVertex?i(this._left.start,this._left.direction,n):i(this._right.start,this._right.direction,n))&&this._helper.copy(this._helper.fromXYZ(n,void 0,this._helper.getM(e.pos)),e.pos)}selectArrowFromStartPoint(e){this._selectedArrow=(0,V.Tj)(this.plane,this._pointToXYZ(e))?1:-1}get selectedArrow(){return this._selectedArrow}signedDistanceToPoint(e){return(0,V.mN)(this.plane,this._pointToXYZ(e))}apply(e){this._offset(e,this.distance)}undo(e){this._offset(e,0)}canAccumulate(e){return e instanceof M&&this._edge.leftVertex.index===e._edge.leftVertex.index&&this._edge.rightVertex.index===e._edge.rightVertex.index&&this._edge.component===e._edge.component&&this._maybeEqualsVec3(this._left.direction,e._left.direction)&&this._maybeEqualsVec3(this._right.direction,e._right.direction)&&(0,y.G)((0,V.Qj)(this._plane),(0,V.Qj)(e._plane))}accumulate(e,t){const i=this._plane[3]-t._plane[3]+t.distance;this._offset(e,i)}accumulateParams(e){const t=e.distance-e._plane[3];this.distance=t+this._plane[3]}clone(){const e=new M(this._helper,this._planeType,this._edge,this.distance,D.DEFERRED);return(0,V.C)(e._plane,this._plane),(0,V.C)(e._offsetPlane,this._offsetPlane),e._maxDistance=this._maxDistance,e._minDistance=this._minDistance,e._left=this._cloneNeighbor(this._left),e._right=this._cloneNeighbor(this._right),e._edgeDirection=(0,y.c)((0,x.vt)(),this._edgeDirection),e}_maybeEqualsVec3(e,t){return null==e&&null==t||null!=e&&null!=t&&(0,y.G)(e,t)}_cloneNeighbor(e){let{start:t,end:i,direction:n,isOriginalDirection:r}=e;return{start:(0,y.c)((0,x.vt)(),t),end:null!=i?(0,y.c)((0,x.vt)(),i):null,direction:(0,y.c)((0,x.vt)(),n),isOriginalDirection:r}}}const T=(0,f.kU)(15),w=.001;var R,D;!function(e){e[e.XYZ=0]="XYZ",e[e.XY=1]="XY"}(R||(R={})),function(e){e[e.IMMEDIATE=0]="IMMEDIATE",e[e.DEFERRED=1]="DEFERRED"}(D||(D={}));class P{constructor(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r.CUMULATIVE;this.origin=e,this.angle=t,this._accumulationType=i}_rotate(e,t){(0,v.e$)(e.pos,e.pos,this.origin,t)}apply(e){this._rotate(e,this.angle)}undo(e){this._rotate(e,-this.angle)}canAccumulate(e){return e instanceof P&&(0,p.aI)(this.origin,e.origin)}accumulate(e,t){const i=t._accumulationType===r.REPLACE;this._rotate(e,i?t.angle-this.angle:t.angle)}accumulateParams(e){const t=e._accumulationType===r.REPLACE;this.angle=t?e.angle:this.angle+e.angle}}class G{constructor(e,t,i,n){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:r.CUMULATIVE;this.origin=e,this.axis1=t,this.factor1=i,this.factor2=n,this._accumulationType=s,this.axis2=(0,m.fA)(t[1],-t[0])}_scale(e,t,i){(0,v.Vj)(e.pos,e.pos,this.origin,this.axis1,t),(0,v.Vj)(e.pos,e.pos,this.origin,this.axis2,i)}apply(e){this._scale(e,this.factor1,this.factor2)}undo(e){this._scale(e,1/this.factor1,1/this.factor2)}canAccumulate(e){return e instanceof G&&(0,p.aI)(this.origin,e.origin)&&(0,p.aI)(this.axis1,e.axis1)}accumulate(e,t){t._accumulationType===r.REPLACE?this._scale(e,t.factor1/this.factor1,t.factor2/this.factor2):this._scale(e,t.factor1,t.factor2)}accumulateParams(e){const t=e._accumulationType===r.REPLACE;this.factor1=t?e.factor1:this.factor1*e.factor1,this.factor2=t?e.factor2:this.factor2*e.factor2}}class Z{constructor(){this._operations=[],this._closed=!1}close(){this._closed=!0}apply(){for(const e of this._operations)e.apply()}undo(){for(let e=this._operations.length-1;e>=0;e--)this._operations[e].undo()}accumulate(e){if(this._closed)return!1;const t=this._operations.length?this._operations[this._operations.length-1]:null;return t&&t.accumulate(e)||(this._operations.push(e),e.apply()),!0}}class C extends s.A{constructor(e){super(),this.data=e,this._undoStack=[],this._redoStack=[],this._listener=this.data.on("change",(e=>{e.addedVertices&&this.emit("vertex-add",{type:"vertex-add",vertices:e.addedVertices,operation:e.operation}),e.removedVertices&&this.emit("vertex-remove",{type:"vertex-remove",vertices:e.removedVertices,operation:e.operation}),e.updatedVertices&&this.emit("vertex-update",{type:"vertex-update",vertices:e.updatedVertices,operation:e.operation})}))}destroy(){this._listener.remove()}splitEdge(e,t){return this._apply(new d(this.data,e,t))}updateVertices(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n.ACCUMULATE_STEPS;return this._apply(new c(this.data,e,t),i)}moveVertices(e,t,i,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:n.ACCUMULATE_STEPS;return this.updateVertices(e,new _(this.data.coordinateHelper,t,i,r),s)}scaleVertices(e,t,i,s,o){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:n.ACCUMULATE_STEPS,h=arguments.length>6&&void 0!==arguments[6]?arguments[6]:r.CUMULATIVE;return this.updateVertices(e,new G(t,i,s,o,h),a)}rotateVertices(e,t,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n.ACCUMULATE_STEPS,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:r.CUMULATIVE;return this.updateVertices(e,new P(t,i,o),s)}removeVertices(e){return this._apply(new l(this.data,e,this._minNumVerticesPerType))}appendVertex(e){return 0===this.data.components.length?null:this._apply(new h(this.data,this.data.components[0],e))}setVertexPosition(e,t){return this._apply(new u(this.data,e,t))}offsetEdge(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n.ACCUMULATE_STEPS;return this.updateVertices([t.leftVertex,t.rightVertex],new M(this.data.coordinateHelper,e,t,i),r)}closeComponent(e){return this.data.components.includes(e)?this._apply(new g(this.data,e)):null}canRemoveVertex(e){return e.vertices.length>this._minNumVerticesPerType}createUndoGroup(){const e=new Z;return this._apply(e),(0,o.hA)((()=>e.close()))}undo(){if(this._undoStack.length>0){const e=this._undoStack.pop();return e.undo(),this._redoStack.push(e),e}return null}redo(){if(this._redoStack.length>0){const e=this._redoStack.pop();return e.apply(),this._undoStack.push(e),e}return null}get canUndo(){return this._undoStack.length>0}get canRedo(){return this._redoStack.length>0}get lastOperation(){return this._undoStack.length>0?this._undoStack[this._undoStack.length-1]:null}get _minNumVerticesPerType(){switch(this.data.type){case"point":return 1;case"polyline":return 2;case"polygon":return 3;default:return 0}}_apply(e){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.ACCUMULATE_STEPS)!==n.NEW_STEP&&null!=this.lastOperation&&this.lastOperation.accumulate(e)||(e.apply(),this._undoStack.push(e),this._redoStack=[]),e}static fromGeometry(e,t){return new C(a.ZE.fromGeometry(e,t))}}},74050:(e,t,i)=>{i.d(t,{Dh:()=>h,IB:()=>l,Vv:()=>n,fg:()=>a,jI:()=>c});i(15941);var n,r=i(19555),s=i(72745);function o(e,t){return e[0]*t[1]-e[1]*t[0]}function a(e,t,i,n){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:i;return(0,r.Re)(u,n,i),(0,r.Re)(g,t,s),function(e,t,i){const n=(0,r.Om)(i,t)/(0,r.m3)(i);(0,r.hs)(e,i,n)}(_,g,u),(0,r.WQ)(e,s,_)}function h(e,t,i,n){(0,r.Re)(u,t,i);const s=n/(0,r.Bw)(u);return(0,r.Ln)(e,i,u,s)}function c(e,t){const i=e.start,s=e.end,a=t.start,h=t.end,c=(0,r.Re)(u,s,i),l=(0,r.Re)(p,h,a),f=o(c,l);if(Math.abs(f)<=d)return[];const v=(0,r.Re)(g,i,a),m=o(l,v)/f,y=o(c,v)/f;if(m>=0){if(y>=0||t.type===n.LINE)return[(0,r.Ln)(_,i,c,m)]}else if(e.type===n.LINE&&(y>=0||t.type===n.LINE))return[(0,r.Ln)(_,i,c,m)];return[]}function l(e,t,i){const s=[],o=(0,r.Re)(u,e.end,e.start),a=(0,r.Re)(p,e.start,t),h=(0,r.m3)(o),c=2*(0,r.Om)(o,a),l=c*c-4*h*((0,r.m3)(a)-i*i);if(0===l){const t=-c/(2*h);(e.type===n.LINE||t>=0)&&s.push((0,r.Ln)(_,e.start,o,t))}else if(l>0){const t=Math.sqrt(l),i=(-c+t)/(2*h);(e.type===n.LINE||i>=0)&&s.push((0,r.Ln)(_,e.start,o,i));const a=(-c-t)/(2*h);(e.type===n.LINE||a>=0)&&s.push((0,r.Ln)(g,e.start,o,a))}return s}!function(e){e[e.RAY=0]="RAY",e[e.LINE=1]="LINE"}(n||(n={}));const d=1e-6,u=(0,s.vt)(),p=(0,s.vt)(),g=(0,s.vt)(),_=(0,s.vt)()}}]);
//# sourceMappingURL=1487.0fbead97.chunk.js.map